import logging
from typing import Dict, Any, Optional, List
import time
import uuid

from ..base_component import Component

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class StructuredMemoryComponent(Component):
    """
    Stores structured memories generated by memory formation processes.
    This component holds the actual memory data, making it loomable as part of
    the InnerSpace's state.
    """

    COMPONENT_TYPE: str = "structured_memory_store"
    DEPENDENCIES: List[str] = []

    # Events this component might handle (e.g., requests to add memory)
    HANDLED_EVENT_TYPES: List[str] = [
        "add_memory_request" # Event-driven way to add memories
    ]

    def __init__(self, element: Optional["BaseElement"] = None, **kwargs):
        """
        Initializes the structured memory store.
        
        Args:
            element: The Element this component is attached to (typically InnerSpace).
            **kwargs: Passthrough for BaseComponent.
        """
        super().__init__(element, **kwargs)
        self._state = {
            # List of memory dictionaries
            # Each dict contains: memory_id, timestamp, source_info, content, metadata
            "memories": []
        }
        logger.info(f"StructuredMemoryComponent initialized for element {element.id if element else 'None'}")

    def add_memory(self, memory_data: Dict[str, Any]) -> Optional[str]:
        """
        Adds a structured memory to the store.

        Args:
            memory_data: A dictionary containing the memory information. Expected keys
                         might include 'source_info', 'content', 'metadata'. 
                         'memory_id' and 'timestamp' will be added if missing.

        Returns:
            The ID of the added memory, or None if failed.
        """
        if not self._is_initialized or not self._is_enabled:
            logger.warning("Cannot add memory: component not initialized or enabled.")
            return None

        memory_entry = memory_data.copy() # Avoid modifying the original dict

        if "memory_id" not in memory_entry:
            memory_entry["memory_id"] = f"mem_{uuid.uuid4().hex[:12]}"
        if "timestamp" not in memory_entry:
            memory_entry["timestamp"] = int(time.time() * 1000)
            
        # Basic validation (ensure core fields exist? Content?) - Optional
        if "content" not in memory_entry:
             logger.warning(f"Adding memory {memory_entry['memory_id']} without 'content' field.")
        
        self._state["memories"].append(memory_entry)
        logger.info(f"Added memory {memory_entry['memory_id']} to store.")
        return memory_entry["memory_id"]

    def get_memories(
        self,
        since_timestamp: Optional[int] = None,
        before_timestamp: Optional[int] = None,
        limit: Optional[int] = None
    ) -> List[Dict[str, Any]]:
        """
        Retrieves stored memories, optionally filtered by time range and count.

        Args:
            since_timestamp: If provided, only return memories created at or after this timestamp.
            before_timestamp: If provided, only return memories created before this timestamp.
            limit: If provided, return only the most recent N memories matching the time filters.

        Returns:
            A list of memory dictionaries, sorted chronologically (oldest first).
        """
        # Get a copy to avoid external modification
        all_memories = sorted(self._state.get("memories", []), key=lambda m: m.get("timestamp", 0))
        
        filtered_memories = all_memories
        
        if since_timestamp is not None:
            filtered_memories = [m for m in filtered_memories if m.get("timestamp", 0) >= since_timestamp]
            
        if before_timestamp is not None:
            filtered_memories = [m for m in filtered_memories if m.get("timestamp", 0) < before_timestamp]
            
        if limit is not None:
            return filtered_memories[-limit:] # Return the last N matching items
        else:
            return filtered_memories

    def get_memory_by_id(self, memory_id: str) -> Optional[Dict[str, Any]]:
        """Retrieves a specific memory by its ID."""
        for memory in self._state.get("memories", []):
            if memory.get("memory_id") == memory_id:
                return memory.copy()
        return None

    def clear_memories(self) -> None:
        """Removes all memories from the store."""
        count = len(self._state.get("memories", []))
        self._state["memories"] = []
        logger.info(f"Cleared {count} memories from the store.")

    def _on_event(self, event: Dict[str, Any], timeline_context: Dict[str, Any]) -> bool:
        """
        Handle events related to adding memories.
        """
        event_type = event.get("event_type")
        if event_type == "add_memory_request":
            memory_data = event.get("data")
            if isinstance(memory_data, dict):
                added_id = self.add_memory(memory_data)
                return added_id is not None
            else:
                logger.warning("Received add_memory_request with invalid or missing data.")
                return False
        
        return False 